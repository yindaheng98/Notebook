# 3D Gaussian Splatting核心CUDA代码注释：反向传播部分

3D高斯前向传播和反向传播的CUDA代码调用栈很类似，都是`RasterizeGaussiansBackwardCUDA`(`RasterizeGaussiansCUDA`)->`backward`(`forward`)->`render/preprocess`，其中的各种初始化过程也都大差不差，看懂了上一篇[前向传播的代码解析](./3D高斯代码解析.md)的调用栈这反向传播的调用栈也自然就懂，不做赘述，我们直接从`render`和`preprocess`开始看：

回忆[上一篇](./3D高斯代码解析.md)中的前向传播过程（`CudaRasterizer::Rasterizer::forward`函数）。
预处理函数`FORWARD::preprocess`计算每一个高斯球投影出来的圆半径及覆盖的范围，其输入高斯球参数和相机位姿，计算每个高斯球的3D协方差`geomState.cov3D`、在该相机视角下的2D协方差矩阵`geomState.conic_opacity`、高斯球中心在成像平面上的位置`geomState.means2D`、距成像平面的深度`geomState.depths`、并用球谐系数算出高斯球在该相机视角下的颜色`geomState.rgb`等。
之后就是对高斯点按tile和深度排序等操作，然后进入`FORWARD::render`函数，以预处理计算好的`geomState.conic_opacity`、`geomState.means2D`、`geomState.rgb`等为输入，按照深度顺序对高斯点进行alpha blending得到最终的渲染图。

`BACKWARD::preprocess`和`BACKWARD::render`分别对应这两个过程的反向传播。
它们在`CudaRasterizer::Rasterizer::backward`里的调用过程也是反着的，先调用`BACKWARD::render`计算高斯点在成像平面上的2D协方差矩阵和颜色等项的梯度，再调用`preprocess`计算各高斯点参数的梯度。

## 对渲染过程的反向传播`BACKWARD::render`

`BACKWARD::render`对`grid`个tile各启动`block`(16x16x1)个线程，即每个像素一个线程运行`renderCUDA`：
```cpp
void BACKWARD::render(
	const dim3 grid, const dim3 block,
	const uint2* ranges,
	const uint32_t* point_list,
	int W, int H,
	const float* bg_color,
	const float2* means2D, // 高斯点投影在像平面上的2D均值位置
	const float4* conic_opacity, // 高斯点投影在像平面上的2D协方差矩阵（叠加透明度）
	const float* colors, // 高斯点在该相机视角下的颜色
	const float* final_Ts,
	const uint32_t* n_contrib,
	const float* dL_dpixels, // 从Pytorch中传过来的渲染图上每个像素的梯度
	float3* dL_dmean2D, // 高斯点投影在像平面上的2D均值位置的梯度（待求解）
	float4* dL_dconic2D, // 高斯点投影在像平面上的2D协方差矩阵（不叠加透明度）的梯度（待求解）
	float* dL_dopacity, // 高斯点透明度的梯度（待求解）
	float* dL_dcolors) // 高斯点颜色的梯度（待求解）
{
	renderCUDA<NUM_CHANNELS> << <grid, block >> >(
		ranges,
		point_list,
		W, H,
		bg_color,
		means2D,
		conic_opacity,
		colors,
		final_Ts,
		n_contrib,
		dL_dpixels,
		dL_dmean2D,
		dL_dconic2D,
		dL_dopacity,
		dL_dcolors
		);
}
```

## `BACKWARD::preprocess`

计算每一个高斯球投影出来的圆半径及覆盖的范围。

```cpp
void BACKWARD::preprocess(
	int P, int D, int M,
	const float3* means3D,
	const int* radii,
	const float* shs,
	const bool* clamped,
	const glm::vec3* scales,
	const glm::vec4* rotations,
	const float scale_modifier,
	const float* cov3Ds,
	const float* viewmatrix,
	const float* projmatrix,
	const float focal_x, float focal_y,
	const float tan_fovx, float tan_fovy,
	const glm::vec3* campos,
	const float3* dL_dmean2D, // 高斯点投影在像平面上的2D均值位置的梯度（BACKWARD::render的计算结果）
	const float* dL_dconic, // 高斯点投影在像平面上的2D协方差矩阵（不叠加透明度）的梯度（BACKWARD::render的计算结果）
	glm::vec3* dL_dmean3D, // 高斯点3D均值位置的梯度（待求解）
	float* dL_dcolor, // 高斯点颜色的梯度（BACKWARD::render的计算结果）
	float* dL_dcov3D, // 高斯点3D协方差矩阵的梯度（待求解）
	float* dL_dsh, // 高斯点球谐系数的梯度（待求解）
	glm::vec3* dL_dscale, // 高斯点scale参数的梯度（待求解）
	glm::vec4* dL_drot) // 高斯点rotation参数的梯度（待求解）
{
	// Propagate gradients for the path of 2D conic matrix computation. 
	// Somewhat long, thus it is its own kernel rather than being part of 
	// "preprocess". When done, loss gradient w.r.t. 3D means has been
	// modified and gradient w.r.t. 3D covariance matrix has been computed.	
	computeCov2DCUDA << <(P + 255) / 256, 256 >> > (
		P,
		means3D,
		radii,
		cov3Ds,
		focal_x,
		focal_y,
		tan_fovx,
		tan_fovy,
		viewmatrix,
		dL_dconic,
		(float3*)dL_dmean3D,
		dL_dcov3D);

	// Propagate gradients for remaining steps: finish 3D mean gradients,
	// propagate color gradients to SH (if desireD), propagate 3D covariance
	// matrix gradients to scale and rotation.
	preprocessCUDA<NUM_CHANNELS> << < (P + 255) / 256, 256 >> > (
		P, D, M,
		(float3*)means3D,
		radii,
		shs,
		clamped,
		(glm::vec3*)scales,
		(glm::vec4*)rotations,
		scale_modifier,
		projmatrix,
		campos,
		(float3*)dL_dmean2D,
		(glm::vec3*)dL_dmean3D,
		dL_dcolor,
		dL_dcov3D,
		dL_dsh,
		dL_dscale,
		dL_drot);
}
```